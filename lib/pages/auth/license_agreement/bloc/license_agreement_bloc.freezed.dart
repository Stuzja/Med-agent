// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'license_agreement_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$LicenseAgreementEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() changePrivacy,
    required TResult Function() changedUserAgreement,
    required TResult Function() clickedContinue,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? changePrivacy,
    TResult? Function()? changedUserAgreement,
    TResult? Function()? clickedContinue,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? changePrivacy,
    TResult Function()? changedUserAgreement,
    TResult Function()? clickedContinue,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(ChangedPrivacy value) changePrivacy,
    required TResult Function(ChangedUserAgreement value) changedUserAgreement,
    required TResult Function(ClickedContinue value) clickedContinue,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(ChangedPrivacy value)? changePrivacy,
    TResult? Function(ChangedUserAgreement value)? changedUserAgreement,
    TResult? Function(ClickedContinue value)? clickedContinue,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(ChangedPrivacy value)? changePrivacy,
    TResult Function(ChangedUserAgreement value)? changedUserAgreement,
    TResult Function(ClickedContinue value)? clickedContinue,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LicenseAgreementEventCopyWith<$Res> {
  factory $LicenseAgreementEventCopyWith(LicenseAgreementEvent value,
          $Res Function(LicenseAgreementEvent) then) =
      _$LicenseAgreementEventCopyWithImpl<$Res, LicenseAgreementEvent>;
}

/// @nodoc
class _$LicenseAgreementEventCopyWithImpl<$Res,
        $Val extends LicenseAgreementEvent>
    implements $LicenseAgreementEventCopyWith<$Res> {
  _$LicenseAgreementEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$StartedImplCopyWith<$Res> {
  factory _$$StartedImplCopyWith(
          _$StartedImpl value, $Res Function(_$StartedImpl) then) =
      __$$StartedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StartedImplCopyWithImpl<$Res>
    extends _$LicenseAgreementEventCopyWithImpl<$Res, _$StartedImpl>
    implements _$$StartedImplCopyWith<$Res> {
  __$$StartedImplCopyWithImpl(
      _$StartedImpl _value, $Res Function(_$StartedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$StartedImpl implements _Started {
  const _$StartedImpl();

  @override
  String toString() {
    return 'LicenseAgreementEvent.started()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StartedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() changePrivacy,
    required TResult Function() changedUserAgreement,
    required TResult Function() clickedContinue,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? changePrivacy,
    TResult? Function()? changedUserAgreement,
    TResult? Function()? clickedContinue,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? changePrivacy,
    TResult Function()? changedUserAgreement,
    TResult Function()? clickedContinue,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(ChangedPrivacy value) changePrivacy,
    required TResult Function(ChangedUserAgreement value) changedUserAgreement,
    required TResult Function(ClickedContinue value) clickedContinue,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(ChangedPrivacy value)? changePrivacy,
    TResult? Function(ChangedUserAgreement value)? changedUserAgreement,
    TResult? Function(ClickedContinue value)? clickedContinue,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(ChangedPrivacy value)? changePrivacy,
    TResult Function(ChangedUserAgreement value)? changedUserAgreement,
    TResult Function(ClickedContinue value)? clickedContinue,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _Started implements LicenseAgreementEvent {
  const factory _Started() = _$StartedImpl;
}

/// @nodoc
abstract class _$$ChangedPrivacyImplCopyWith<$Res> {
  factory _$$ChangedPrivacyImplCopyWith(_$ChangedPrivacyImpl value,
          $Res Function(_$ChangedPrivacyImpl) then) =
      __$$ChangedPrivacyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ChangedPrivacyImplCopyWithImpl<$Res>
    extends _$LicenseAgreementEventCopyWithImpl<$Res, _$ChangedPrivacyImpl>
    implements _$$ChangedPrivacyImplCopyWith<$Res> {
  __$$ChangedPrivacyImplCopyWithImpl(
      _$ChangedPrivacyImpl _value, $Res Function(_$ChangedPrivacyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ChangedPrivacyImpl implements ChangedPrivacy {
  const _$ChangedPrivacyImpl();

  @override
  String toString() {
    return 'LicenseAgreementEvent.changePrivacy()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ChangedPrivacyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() changePrivacy,
    required TResult Function() changedUserAgreement,
    required TResult Function() clickedContinue,
  }) {
    return changePrivacy();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? changePrivacy,
    TResult? Function()? changedUserAgreement,
    TResult? Function()? clickedContinue,
  }) {
    return changePrivacy?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? changePrivacy,
    TResult Function()? changedUserAgreement,
    TResult Function()? clickedContinue,
    required TResult orElse(),
  }) {
    if (changePrivacy != null) {
      return changePrivacy();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(ChangedPrivacy value) changePrivacy,
    required TResult Function(ChangedUserAgreement value) changedUserAgreement,
    required TResult Function(ClickedContinue value) clickedContinue,
  }) {
    return changePrivacy(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(ChangedPrivacy value)? changePrivacy,
    TResult? Function(ChangedUserAgreement value)? changedUserAgreement,
    TResult? Function(ClickedContinue value)? clickedContinue,
  }) {
    return changePrivacy?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(ChangedPrivacy value)? changePrivacy,
    TResult Function(ChangedUserAgreement value)? changedUserAgreement,
    TResult Function(ClickedContinue value)? clickedContinue,
    required TResult orElse(),
  }) {
    if (changePrivacy != null) {
      return changePrivacy(this);
    }
    return orElse();
  }
}

abstract class ChangedPrivacy implements LicenseAgreementEvent {
  const factory ChangedPrivacy() = _$ChangedPrivacyImpl;
}

/// @nodoc
abstract class _$$ChangedUserAgreementImplCopyWith<$Res> {
  factory _$$ChangedUserAgreementImplCopyWith(_$ChangedUserAgreementImpl value,
          $Res Function(_$ChangedUserAgreementImpl) then) =
      __$$ChangedUserAgreementImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ChangedUserAgreementImplCopyWithImpl<$Res>
    extends _$LicenseAgreementEventCopyWithImpl<$Res,
        _$ChangedUserAgreementImpl>
    implements _$$ChangedUserAgreementImplCopyWith<$Res> {
  __$$ChangedUserAgreementImplCopyWithImpl(_$ChangedUserAgreementImpl _value,
      $Res Function(_$ChangedUserAgreementImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ChangedUserAgreementImpl implements ChangedUserAgreement {
  const _$ChangedUserAgreementImpl();

  @override
  String toString() {
    return 'LicenseAgreementEvent.changedUserAgreement()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChangedUserAgreementImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() changePrivacy,
    required TResult Function() changedUserAgreement,
    required TResult Function() clickedContinue,
  }) {
    return changedUserAgreement();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? changePrivacy,
    TResult? Function()? changedUserAgreement,
    TResult? Function()? clickedContinue,
  }) {
    return changedUserAgreement?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? changePrivacy,
    TResult Function()? changedUserAgreement,
    TResult Function()? clickedContinue,
    required TResult orElse(),
  }) {
    if (changedUserAgreement != null) {
      return changedUserAgreement();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(ChangedPrivacy value) changePrivacy,
    required TResult Function(ChangedUserAgreement value) changedUserAgreement,
    required TResult Function(ClickedContinue value) clickedContinue,
  }) {
    return changedUserAgreement(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(ChangedPrivacy value)? changePrivacy,
    TResult? Function(ChangedUserAgreement value)? changedUserAgreement,
    TResult? Function(ClickedContinue value)? clickedContinue,
  }) {
    return changedUserAgreement?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(ChangedPrivacy value)? changePrivacy,
    TResult Function(ChangedUserAgreement value)? changedUserAgreement,
    TResult Function(ClickedContinue value)? clickedContinue,
    required TResult orElse(),
  }) {
    if (changedUserAgreement != null) {
      return changedUserAgreement(this);
    }
    return orElse();
  }
}

abstract class ChangedUserAgreement implements LicenseAgreementEvent {
  const factory ChangedUserAgreement() = _$ChangedUserAgreementImpl;
}

/// @nodoc
abstract class _$$ClickedContinueImplCopyWith<$Res> {
  factory _$$ClickedContinueImplCopyWith(_$ClickedContinueImpl value,
          $Res Function(_$ClickedContinueImpl) then) =
      __$$ClickedContinueImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClickedContinueImplCopyWithImpl<$Res>
    extends _$LicenseAgreementEventCopyWithImpl<$Res, _$ClickedContinueImpl>
    implements _$$ClickedContinueImplCopyWith<$Res> {
  __$$ClickedContinueImplCopyWithImpl(
      _$ClickedContinueImpl _value, $Res Function(_$ClickedContinueImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClickedContinueImpl implements ClickedContinue {
  const _$ClickedContinueImpl();

  @override
  String toString() {
    return 'LicenseAgreementEvent.clickedContinue()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ClickedContinueImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() changePrivacy,
    required TResult Function() changedUserAgreement,
    required TResult Function() clickedContinue,
  }) {
    return clickedContinue();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? changePrivacy,
    TResult? Function()? changedUserAgreement,
    TResult? Function()? clickedContinue,
  }) {
    return clickedContinue?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? changePrivacy,
    TResult Function()? changedUserAgreement,
    TResult Function()? clickedContinue,
    required TResult orElse(),
  }) {
    if (clickedContinue != null) {
      return clickedContinue();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(ChangedPrivacy value) changePrivacy,
    required TResult Function(ChangedUserAgreement value) changedUserAgreement,
    required TResult Function(ClickedContinue value) clickedContinue,
  }) {
    return clickedContinue(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(ChangedPrivacy value)? changePrivacy,
    TResult? Function(ChangedUserAgreement value)? changedUserAgreement,
    TResult? Function(ClickedContinue value)? clickedContinue,
  }) {
    return clickedContinue?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(ChangedPrivacy value)? changePrivacy,
    TResult Function(ChangedUserAgreement value)? changedUserAgreement,
    TResult Function(ClickedContinue value)? clickedContinue,
    required TResult orElse(),
  }) {
    if (clickedContinue != null) {
      return clickedContinue(this);
    }
    return orElse();
  }
}

abstract class ClickedContinue implements LicenseAgreementEvent {
  const factory ClickedContinue() = _$ClickedContinueImpl;
}

/// @nodoc
mixin _$LicenseAgreementState {
  dynamic get acceptUserAgreement => throw _privateConstructorUsedError;
  dynamic get acceptPrivacyPolicy => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            dynamic acceptUserAgreement, dynamic acceptPrivacyPolicy)
        initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(dynamic acceptUserAgreement, dynamic acceptPrivacyPolicy)?
        initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(dynamic acceptUserAgreement, dynamic acceptPrivacyPolicy)?
        initial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $LicenseAgreementStateCopyWith<LicenseAgreementState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LicenseAgreementStateCopyWith<$Res> {
  factory $LicenseAgreementStateCopyWith(LicenseAgreementState value,
          $Res Function(LicenseAgreementState) then) =
      _$LicenseAgreementStateCopyWithImpl<$Res, LicenseAgreementState>;
  @useResult
  $Res call({dynamic acceptUserAgreement, dynamic acceptPrivacyPolicy});
}

/// @nodoc
class _$LicenseAgreementStateCopyWithImpl<$Res,
        $Val extends LicenseAgreementState>
    implements $LicenseAgreementStateCopyWith<$Res> {
  _$LicenseAgreementStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? acceptUserAgreement = freezed,
    Object? acceptPrivacyPolicy = freezed,
  }) {
    return _then(_value.copyWith(
      acceptUserAgreement: freezed == acceptUserAgreement
          ? _value.acceptUserAgreement
          : acceptUserAgreement // ignore: cast_nullable_to_non_nullable
              as dynamic,
      acceptPrivacyPolicy: freezed == acceptPrivacyPolicy
          ? _value.acceptPrivacyPolicy
          : acceptPrivacyPolicy // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res>
    implements $LicenseAgreementStateCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({dynamic acceptUserAgreement, dynamic acceptPrivacyPolicy});
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$LicenseAgreementStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? acceptUserAgreement = freezed,
    Object? acceptPrivacyPolicy = freezed,
  }) {
    return _then(_$InitialImpl(
      acceptUserAgreement: freezed == acceptUserAgreement
          ? _value.acceptUserAgreement!
          : acceptUserAgreement,
      acceptPrivacyPolicy: freezed == acceptPrivacyPolicy
          ? _value.acceptPrivacyPolicy!
          : acceptPrivacyPolicy,
    ));
  }
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl(
      {this.acceptUserAgreement = false, this.acceptPrivacyPolicy = false});

  @override
  @JsonKey()
  final dynamic acceptUserAgreement;
  @override
  @JsonKey()
  final dynamic acceptPrivacyPolicy;

  @override
  String toString() {
    return 'LicenseAgreementState.initial(acceptUserAgreement: $acceptUserAgreement, acceptPrivacyPolicy: $acceptPrivacyPolicy)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InitialImpl &&
            const DeepCollectionEquality()
                .equals(other.acceptUserAgreement, acceptUserAgreement) &&
            const DeepCollectionEquality()
                .equals(other.acceptPrivacyPolicy, acceptPrivacyPolicy));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(acceptUserAgreement),
      const DeepCollectionEquality().hash(acceptPrivacyPolicy));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InitialImplCopyWith<_$InitialImpl> get copyWith =>
      __$$InitialImplCopyWithImpl<_$InitialImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            dynamic acceptUserAgreement, dynamic acceptPrivacyPolicy)
        initial,
  }) {
    return initial(acceptUserAgreement, acceptPrivacyPolicy);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(dynamic acceptUserAgreement, dynamic acceptPrivacyPolicy)?
        initial,
  }) {
    return initial?.call(acceptUserAgreement, acceptPrivacyPolicy);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(dynamic acceptUserAgreement, dynamic acceptPrivacyPolicy)?
        initial,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(acceptUserAgreement, acceptPrivacyPolicy);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements LicenseAgreementState {
  const factory _Initial(
      {final dynamic acceptUserAgreement,
      final dynamic acceptPrivacyPolicy}) = _$InitialImpl;

  @override
  dynamic get acceptUserAgreement;
  @override
  dynamic get acceptPrivacyPolicy;
  @override
  @JsonKey(ignore: true)
  _$$InitialImplCopyWith<_$InitialImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$LicenseAgreementCommand {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() navToNextPage,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? navToNextPage,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? navToNextPage,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NavToNextPage value) navToNextPage,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NavToNextPage value)? navToNextPage,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NavToNextPage value)? navToNextPage,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LicenseAgreementCommandCopyWith<$Res> {
  factory $LicenseAgreementCommandCopyWith(LicenseAgreementCommand value,
          $Res Function(LicenseAgreementCommand) then) =
      _$LicenseAgreementCommandCopyWithImpl<$Res, LicenseAgreementCommand>;
}

/// @nodoc
class _$LicenseAgreementCommandCopyWithImpl<$Res,
        $Val extends LicenseAgreementCommand>
    implements $LicenseAgreementCommandCopyWith<$Res> {
  _$LicenseAgreementCommandCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$NavToNextPageImplCopyWith<$Res> {
  factory _$$NavToNextPageImplCopyWith(
          _$NavToNextPageImpl value, $Res Function(_$NavToNextPageImpl) then) =
      __$$NavToNextPageImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NavToNextPageImplCopyWithImpl<$Res>
    extends _$LicenseAgreementCommandCopyWithImpl<$Res, _$NavToNextPageImpl>
    implements _$$NavToNextPageImplCopyWith<$Res> {
  __$$NavToNextPageImplCopyWithImpl(
      _$NavToNextPageImpl _value, $Res Function(_$NavToNextPageImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NavToNextPageImpl implements NavToNextPage {
  _$NavToNextPageImpl();

  @override
  String toString() {
    return 'LicenseAgreementCommand.navToNextPage()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NavToNextPageImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() navToNextPage,
  }) {
    return navToNextPage();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? navToNextPage,
  }) {
    return navToNextPage?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? navToNextPage,
    required TResult orElse(),
  }) {
    if (navToNextPage != null) {
      return navToNextPage();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NavToNextPage value) navToNextPage,
  }) {
    return navToNextPage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NavToNextPage value)? navToNextPage,
  }) {
    return navToNextPage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NavToNextPage value)? navToNextPage,
    required TResult orElse(),
  }) {
    if (navToNextPage != null) {
      return navToNextPage(this);
    }
    return orElse();
  }
}

abstract class NavToNextPage implements LicenseAgreementCommand {
  factory NavToNextPage() = _$NavToNextPageImpl;
}
